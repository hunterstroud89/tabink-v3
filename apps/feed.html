<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <title>Feed</title>
  <link rel="stylesheet" href="../assets/style.css" />
  <script src="../cordova.js"></script>
  <script src="../lib/sql-wasm.js"></script>
  <script src="../functions/db.js"></script>
  <script src="../functions/config.js"></script>
  <script src="../functions/settings.js"></script>
  
  <script>
    // Load SVG icon sprite
    fetch('../assets/icons/icons.svg')
      .then(response => response.text())
      .then(data => {
        const div = document.createElement('div');
        div.style.display = 'none';
        div.innerHTML = data;
        document.body.insertBefore(div, document.body.firstChild);
      })
      .catch(err => console.error('Failed to load icons:', err));
  </script>
</head>
<body>
  <!-- Topbar -->
  <div class="topbar">
    <div class="topbar-title" style="text-align: left;">
      <a href="../index.html" style="color: inherit; text-decoration: none; opacity: 0.6;">Home</a>
      <span style="opacity: 0.4; margin: 0 var(--space-xs);">/</span>
      <span onclick="showFeedMenu()" style="cursor: pointer;">Feed â–¼</span>
    </div>
    <div class="topbar-actions">
      <button id="refreshBtn" onclick="refreshFeeds()">â†» Refresh</button>
      <button onclick="showManageFeedsPopup()">âš™ Feeds</button>
    </div>
  </div>

  <main class="container">
    <div id="articlesContainer">
      <p class="muted text-sm" style="text-align: center; padding: var(--space-lg);">
        No articles yet. Click "âš™ Feeds" to add RSS feeds, then "â†» Refresh" to download.
      </p>
    </div>
  </main>

  <!-- Loading Notification -->
  <div class="notification-overlay" id="loadingOverlay"></div>
  <div class="notification" id="loadingNotification">
    <div class="notification-title">ðŸ”„ Refreshing Feeds</div>
    <div class="notification-message">This may take a minute on slower devices...</div>
  </div>

  <script>
    let currentFilter = 'all';
    let currentFeedFilter = null; // Track selected feed name for filtering

        // Helper function to escape HTML
    function escapeHtml(text) {
      const div = document.createElement('div');
      div.textContent = text;
      return div.innerHTML;
    }
    
    // Helper function to decode HTML entities
    function decodeHtml(html) {
      const txt = document.createElement('textarea');
      txt.innerHTML = html;
      return txt.value;
    }

    // Initialize
    window.addEventListener('DOMContentLoaded', async () => {
      await db.init();
      await cleanupOldArticles(); // Auto-cleanup on page load
      
      // Update refresh button based on online status
      updateRefreshButtonState();
      window.addEventListener('online', updateRefreshButtonState);
      window.addEventListener('offline', updateRefreshButtonState);
      
      // Check if we should open a specific article
      const articleToOpen = localStorage.getItem('feed:openArticle');
      if (articleToOpen) {
        localStorage.removeItem('feed:openArticle');
        await renderArticles();
        // Small delay to ensure articles are rendered
        setTimeout(() => openArticle(articleToOpen), 100);
      } else {
        await renderArticles();
      }
    });

    // Update refresh button state based on online status
    function updateRefreshButtonState() {
      const refreshBtn = document.getElementById('refreshBtn');
      if (!navigator.onLine) {
        refreshBtn.disabled = true;
        refreshBtn.style.opacity = '0.5';
        refreshBtn.style.cursor = 'not-allowed';
        refreshBtn.title = 'No internet connection';
      } else {
        refreshBtn.disabled = false;
        refreshBtn.style.opacity = '1';
        refreshBtn.style.cursor = 'pointer';
        refreshBtn.title = 'Refresh feeds from server';
      }
    }

    // Auto-cleanup old articles
    async function cleanupOldArticles() {
      // Delete articles older than configured days (except saved ones)
      const maxAgeDays = CONFIG.MAX_ARTICLE_AGE_DAYS || 30;
      const cutoffDate = new Date();
      cutoffDate.setDate(cutoffDate.getDate() - maxAgeDays);
      
      db.run(`
        DELETE FROM feed_articles 
        WHERE saved = 0 
        AND datetime(pubDate) < datetime('${cutoffDate.toISOString()}')
      `);
      
      // Enforce article limit (from config)
      const maxArticles = CONFIG.MAX_ARTICLES || 500;
      const unsavedCount = db.all('SELECT COUNT(*) as count FROM feed_articles WHERE saved = 0')[0].count;
      
      if (unsavedCount > maxArticles) {
        const deleteCount = unsavedCount - maxArticles;
        db.run(`
          DELETE FROM feed_articles 
          WHERE id IN (
            SELECT id FROM feed_articles 
            WHERE saved = 0 
            ORDER BY datetime(pubDate) ASC 
            LIMIT ?
          )
        `, [deleteCount]);
      }
      
      // Clean up orphaned images
      db.run(`
        DELETE FROM feed_images 
        WHERE articleId NOT IN (SELECT id FROM feed_articles)
      `);
      
      db.save();
      console.log('Auto-cleanup complete');
    }

    // Sync feeds from server
    async function syncFromServer(silent = false) {
      try {
        // Fetch feeds from server's localStorage
        // We'll create a server endpoint to export feeds
        const serverUrl = CONFIG.SERVER_URL || 'https://www.hunter-stroud.com/tabink-server';
        
        // Try to fetch from a server endpoint (we'll create this)
        let response;
        try {
          response = await fetch(`${serverUrl}/server.php?action=feeds`);
        } catch (err) {
          // Silently fail if server not available
          if (!silent) {
            console.log('Server feeds not available, using local feeds');
          }
          return;
        }
        
        if (!response.ok) {
          if (!silent) {
            console.log('Server returned: ' + response.status);
          }
          return;
        }
        
        const feeds = await response.json();
        
        if (!Array.isArray(feeds) || feeds.length === 0) {
          if (!silent) {
            console.log('No feeds found on server');
          }
          return;
        }
        
        // Get current feeds
        const currentFeeds = await db.getFeeds();
        
        // Check if feeds are different
        const currentUrls = new Set(currentFeeds.map(f => f.url));
        const serverUrls = new Set(feeds.map(f => f.url));
        const feedsChanged = currentFeeds.length !== feeds.length || 
                            [...currentUrls].some(url => !serverUrls.has(url)) ||
                            [...serverUrls].some(url => !currentUrls.has(url));
        
        if (feedsChanged) {
          // Clear current feeds (but keep articles!)
          for (const feed of currentFeeds) {
            await db.deleteFeed(feed.url);
          }
          
          // Import server feeds
          for (const feed of feeds) {
            if (feed.name && feed.url) {
              await db.addFeed(feed.name, feed.url);
            }
          }
          
          if (!silent) {
            console.log(`âœ“ Synced ${feeds.length} feeds from server`);
          }
        }
        
      } catch (error) {
        if (!silent) {
          console.error('Sync error:', error);
        }
      }
    }

    // Download articles from server (already fetched server-side)
    // NEW: Incremental sync - only download articles published after our last sync
    async function downloadArticlesFromServer() {
      try {
        const serverUrl = CONFIG.SERVER_URL || 'https://www.hunter-stroud.com/tabink-server';
        
        // Get the most recent article date we have locally
        let url = `${serverUrl}/server.php?action=articles`;
        
        try {
          const mostRecentArticle = db.all(`
            SELECT pubDate FROM feed_articles 
            WHERE saved = 0
            ORDER BY pubDate DESC 
            LIMIT 1
          `);
          
          // If we have articles, only fetch newer ones
          if (mostRecentArticle && mostRecentArticle.length > 0 && mostRecentArticle[0].pubDate) {
            const lastSync = mostRecentArticle[0].pubDate;
            url += `&since=${encodeURIComponent(lastSync)}`;
            console.log(`ðŸ“¥ Fetching articles newer than ${lastSync}`);
          } else {
            console.log(`ðŸ“¥ First sync - fetching all articles`);
          }
        } catch (dbError) {
          console.warn('Could not query recent articles:', dbError);
          console.log(`ðŸ“¥ First sync - fetching all articles`);
        }
        
        const response = await fetch(url);
        
        if (!response.ok) {
          throw new Error(`Server returned ${response.status}`);
        }
        
        const data = await response.json();
        
        if (!data.articles || data.articles.length === 0) {
          console.log('No new articles on server.');
          return {downloaded: 0, saved: 0, new: 0};
        }
        
        let saved = 0;
        let newArticles = 0;
        
        // Save each article to local database
        for (const article of data.articles) {
          // Generate stable article ID from guid/link
          const guid = article.guid || article.link || (article.title + article.feedUrl);
          let hash = 0;
          for (let i = 0; i < guid.length; i++) {
            const char = guid.charCodeAt(i);
            hash = ((hash << 5) - hash) + char;
            hash = hash & hash;
          }
          const articleId = 'article_' + Math.abs(hash).toString(36);
          
          // Check if article already exists
          const existingArticle = db.all('SELECT id FROM feed_articles WHERE id = ?', [articleId]);
          if (existingArticle && existingArticle.length > 0) {
            continue; // Skip duplicates
          }
          
          // Extract image URLs from server's {url, local} format
          let imageUrls = [];
          if (article.images && Array.isArray(article.images)) {
            imageUrls = article.images.map(img => {
              // Server sends {url: "...", local: "..."} objects
              if (typeof img === 'object' && img.local) {
                // Use server's local cached image URL
                return `${serverUrl}/${img.local}`;
              } else if (typeof img === 'object' && img.url) {
                // Fallback to original URL
                return img.url;
              } else if (typeof img === 'string') {
                // Old format: just URL string
                return img;
              }
              return null;
            }).filter(url => url !== null);
          }
          
          const articleData = {
            id: articleId,
            title: article.title || 'Untitled',
            link: article.link || '',
            description: article.description || '',
            content: article.content || article.description || '',
            preview: (article.content || article.description || '').substring(0, 200),
            pubDate: article.pubDate ? new Date(article.pubDate).toISOString() : new Date().toISOString(),
            guid: article.guid || article.link,
            feedUrl: article.feedUrl || '',
            feedName: article.feedName || 'Unknown',
            savedAt: new Date().toISOString(),
            read: false,
            saved: false,
            images: imageUrls
          };
          
          try {
            await db.saveArticle(articleData);
            saved++;
            newArticles++;
          } catch (err) {
            console.warn('Failed to save article:', err.message);
          }
        }
        
        console.log(`âœ“ Downloaded ${data.articles.length} articles from server, saved ${saved} new articles`);
        
        // ENFORCE ARTICLE LIMIT (keep only 500 most recent unsaved articles)
        await enforceArticleLimit(500);
        
        return {
          downloaded: data.articles.length,
          saved: saved,
          new: newArticles,
          lastRefresh: data.lastRefresh
        };
        
      } catch (error) {
        console.error('Download from server failed:', error);
        return {downloaded: 0, saved: 0, new: 0};
      }
    }
    
    // NEW: Enforce article limit - delete oldest unsaved articles if count exceeds limit
    async function enforceArticleLimit(maxArticles) {
      try {
        maxArticles = maxArticles || CONFIG.MAX_ARTICLES || 500;
        
        const unsavedCount = db.all('SELECT COUNT(*) as count FROM feed_articles WHERE saved = 0')[0].count;
        
        if (unsavedCount > maxArticles) {
          const deleteCount = unsavedCount - maxArticles;
          console.log(`âš ï¸ Article limit reached (${unsavedCount}/${maxArticles}). Deleting ${deleteCount} oldest articles...`);
          
          // Delete oldest unsaved articles (no datetime() function)
          db.run(`
            DELETE FROM feed_articles 
            WHERE id IN (
              SELECT id FROM feed_articles 
              WHERE saved = 0 
              ORDER BY pubDate ASC 
              LIMIT ?
            )
          `, [deleteCount]);
          
          // Clean up orphaned images
          db.run(`
            DELETE FROM feed_images 
            WHERE articleId NOT IN (SELECT id FROM feed_articles)
          `);
          
          db.save();
          console.log(`âœ“ Deleted ${deleteCount} old articles. Now at ${maxArticles} articles.`);
        }
      } catch (error) {
        console.error('Error enforcing article limit:', error);
      }
    }

    // Refresh all feeds
    async function refreshFeeds() {
      // Check if online
      if (!navigator.onLine) {
        alert('ðŸ“¡ No internet connection\n\nYou need to be online to refresh feeds.');
        return;
      }
      
      console.log('ðŸ”„ Starting refresh - checking for new articles');
      
      // Show loading notification
      const loadingOverlay = document.getElementById('loadingOverlay');
      const loadingNotification = document.getElementById('loadingNotification');
      loadingOverlay.classList.add('active');
      loadingNotification.classList.add('active');
      
      try {
        // Add timeout for the entire operation (2 minutes)
        const timeoutPromise = new Promise((_, reject) => 
          setTimeout(() => reject(new Error('Operation timed out. Please try again.')), 120000)
        );
        
        const refreshPromise = async () => {
          // Sync feeds list from server
          await syncFromServer(true);
          
          const feeds = await db.getFeeds();
          
          if (feeds.length === 0) {
            alert('No feeds available. Please add feeds on the server first.\n\nGo to: https://www.hunter-stroud.com/tabink-server/');
            await renderArticles();
            return;
          }

          // Download new articles from server (existing ones are skipped)
          const result = await downloadArticlesFromServer();
          
          if (result.saved > 0) {
            console.log('Saving database after downloading articles...');
            await db.save();
            console.log('Database saved successfully!');
            await renderArticles();
            
            alert(`âœ“ Downloaded ${result.new} new articles!\n\nLast server refresh: ${result.lastRefresh ? new Date(result.lastRefresh).toLocaleString() : 'Unknown'}`);
          } else {
            await renderArticles();
            alert('No new articles found.\n\nEverything is up to date!');
          }
        };
        
        await Promise.race([refreshPromise(), timeoutPromise]);
        
      } catch (error) {
        console.error('Refresh error:', error);
        alert('âš ï¸ Refresh failed\n\n' + error.message);
        await renderArticles();
      } finally {
        // Hide loading notification
        loadingOverlay.classList.remove('active');
        loadingNotification.classList.remove('active');
      }
    }

    // Clear database
    // Render articles
    async function renderArticles() {
      const articles = await db.getArticles();
      console.log('Total articles from DB:', articles.length);
      if (articles.length > 0) {
        console.log('First 5 articles:', articles.slice(0, 5).map(a => ({
          title: a.title.substring(0, 40),
          pubDate: a.pubDate,
          feedName: a.feedName
        })));
      }
      
      const container = document.getElementById('articlesContainer');
      
      if (articles.length === 0) {
        container.innerHTML = 
          '<p class="muted text-sm" style="text-align: center; padding: var(--space-lg);">No articles yet. Click "âš™ Feeds" to add RSS feeds.</p>';
        return;
      }

      // Sort articles by date (newest first) - do this in JavaScript to be consistent across browsers
      articles.sort((a, b) => {
        const dateA = new Date(a.pubDate).getTime();
        const dateB = new Date(b.pubDate).getTime();
        return dateB - dateA; // Descending order (newest first)
      });

      // Filter articles
      let filteredArticles = articles;
      if (currentFilter === 'unread') {
        filteredArticles = articles.filter(a => !a.read);
      } else if (currentFilter === 'read') {
        filteredArticles = articles.filter(a => a.read);
      } else if (currentFilter === 'saved') {
        filteredArticles = articles.filter(a => a.saved);
      }

      // Apply feed filter if set
      if (currentFeedFilter) {
        filteredArticles = filteredArticles.filter(a => a.feedName === currentFeedFilter);
      }

      if (filteredArticles.length === 0) {
        container.innerHTML = 
          '<p class="muted text-sm" style="text-align: center; padding: var(--space-lg);">No articles match this filter.</p>';
        return;
      }

      let html = '';
      filteredArticles.forEach((article) => {
        // Parse date more carefully
        const date = article.pubDate ? new Date(article.pubDate) : new Date();
        
        // Debug: log the first article's date info
        if (filteredArticles.indexOf(article) === 0) {
          console.log('Debug first article:', {
            pubDate: article.pubDate,
            parsedDate: date,
            isValid: !isNaN(date.getTime()),
            timestamp: date.getTime()
          });
        }
        
        const timeAgo = (!isNaN(date.getTime())) ? getTimeAgo(date) : 'Unknown date';
        const readStyle = article.read ? 'opacity: 0.6;' : '';
        const savedBadge = article.saved ? '<span style="color: gold; font-size: 20px; margin-left: 4px;">â˜…</span>' : '';
        const coverImage = article.images && article.images.length > 0 ? article.images[0] : null;
        
        html += `
          <div class="card" style="margin-bottom: var(--space-md); cursor: pointer; padding: 0; overflow: hidden; ${readStyle}" onclick="openArticle('${article.id}')">
            ${coverImage ? `
              <img src="${escapeHtml(coverImage)}" 
                   style="width: 100%; height: 250px; object-fit: cover; display: block; border-bottom: 2px solid var(--border-color);" 
                   onerror="this.style.display='none';" />
            ` : ''}
            <div style="padding: var(--space-md);">
              <h3 style="margin: 0 0 var(--space-xs) 0;">
                ${escapeHtml(article.title)}${savedBadge}
              </h3>
              <p class="text-sm">${escapeHtml(article.preview || article.content?.substring(0, 150) || 'No preview')}${(article.preview || article.content)?.length >= 150 ? '...' : ''}</p>
              <div style="display: flex; justify-content: space-between; align-items: baseline; margin-top: var(--space-sm);">
                <span class="text-sm muted">${escapeHtml(article.feedName || 'Unknown')}</span>
                <span class="text-sm muted">${timeAgo}</span>
              </div>
            </div>
          </div>
        `;
      });

      container.innerHTML = html;
    }

    // Show feed menu
    async function showFeedMenu() {
      const articles = await db.getArticles();
      const unreadCount = articles.filter(a => !a.read).length;
      const savedCount = articles.filter(a => a.saved).length;
      
      let popupHTML = `
        <div class="popup active">
          <div class="popup-header">
            <h3 class="popup-title">
              <svg class="icon icon-lg" style="vertical-align: middle; margin-right: var(--space-xs);">
                <use href="#icon-file"></use>
              </svg>
              Feed Menu
            </h3>
            <button class="close-btn" onclick="hidePopup()"></button>
          </div>
          <div class="popup-content">
            <div class="popup-item${currentFilter === 'all' ? ' active' : ''}" data-number="1">
              <div style="flex:1;cursor:pointer" onclick="filterFeed('all')">
                <strong>All Articles</strong>
                <div class="text-sm muted">${articles.length} total</div>
              </div>
            </div>
            <div class="popup-item${currentFilter === 'unread' ? ' active' : ''}" data-number="2">
              <div style="flex:1;cursor:pointer" onclick="filterFeed('unread')">
                <strong>Unread</strong>
                <div class="text-sm muted">${unreadCount} unread</div>
              </div>
            </div>
            <div class="popup-item${currentFilter === 'saved' ? ' active' : ''}" data-number="3">
              <div style="flex:1;cursor:pointer" onclick="filterFeed('saved')">
                <strong>â˜… Saved</strong>
                <div class="text-sm muted">${savedCount} saved</div>
              </div>
            </div>
          </div>
        </div>
        <div class="popup-overlay active" onclick="hidePopup()"></div>
      `;
      
      document.body.insertAdjacentHTML('beforeend', popupHTML);
    }

    // Filter feed
    function filterFeed(filter) {
      currentFilter = filter;
      hidePopup();
      renderArticles();
    }

    // Open article
    async function openArticle(articleId) {
      const articles = await db.getArticles();
      const article = articles.find(a => a.id === articleId);
      if (!article) return;
      
      // Mark as read
      if (!article.read) {
        await db.updateArticle(articleId, { read: true });
      }
      
      const dateStr = new Date(article.pubDate).toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' });
      const saveIcon = article.saved ? 'â˜…' : 'â˜†';
      
      let imagesHTML = '';
      if (article.images && article.images.length > 0) {
        imagesHTML = '<div style="margin-bottom: var(--space-md);">';
        article.images.forEach(imgSrc => {
          imagesHTML += `<img src="${escapeHtml(imgSrc)}" style="max-width: 100%; height: auto; margin-bottom: var(--space-sm); border: 2px solid var(--border-color);" onerror="this.style.display='none'" />`;
        });
        imagesHTML += '</div>';
      }
      
      // Format content with proper paragraphs
      const decodedContent = decodeHtml(article.content || article.preview || 'No content available');
      const formattedContent = decodedContent
        .split('\n\n')
        .map(para => `<p style="margin-bottom: var(--space-md);">${escapeHtml(para)}</p>`)
        .join('');
      
      let popupHTML = `
        <div class="popup popup-file active">
          <div class="popup-header" style="align-items: flex-start;">
            <h3 class="popup-title" style="margin: 0; overflow: visible; white-space: normal; word-wrap: break-word; max-width: calc(100% - 50px);">${escapeHtml(article.title)}</h3>
            <button class="close-btn" onclick="hidePopup()" style="flex-shrink: 0;"></button>
          </div>
          <div class="popup-content" style="max-height: 70vh; overflow-y: auto;">
            <div style="padding: var(--space-md); line-height: 1.8; font-size: 16px;">
              ${imagesHTML}
              ${formattedContent}
            </div>
          </div>
          <div class="popup-footer" style="flex-wrap: wrap; gap: var(--space-xs);">
            <span style="overflow: hidden; text-overflow: ellipsis; white-space: nowrap; flex-shrink: 1; min-width: 0;">${escapeHtml(article.feedName || 'Unknown')} â€¢ ${dateStr}</span>
            <span style="flex-shrink: 0; white-space: nowrap;">
              <button onclick="toggleSave('${articleId}')" style="background: none; border: none; cursor: pointer; font: inherit; color: inherit; padding: 0; font-size: 18px;">${saveIcon}</button>
              <button onclick="deleteArticle('${articleId}')" style="background: none; border: none; cursor: pointer; font: inherit; color: inherit; text-decoration: underline; padding: 0; margin-left: 8px;">Delete</button>
              ${article.link ? ` â€¢ <a href="${escapeHtml(article.link)}" target="_blank" style="font: inherit; color: inherit; text-decoration: none;">View online â†—</a>` : ''}
            </span>
          </div>
        </div>
        <div class="popup-overlay active" onclick="hidePopup()"></div>
      `;
      
      document.body.insertAdjacentHTML('beforeend', popupHTML);
    }

    // Toggle save
    async function toggleSave(articleId) {
      event.stopPropagation();
      const articles = await db.getArticles();
      const article = articles.find(a => a.id === articleId);
      if (article) {
        await db.updateArticle(articleId, { saved: !article.saved });
        hidePopup();
        await renderArticles();
      }
    }

    // Delete article
    async function deleteArticle(articleId) {
      if (confirm('Delete this article?')) {
        await db.deleteArticle(articleId);
        hidePopup();
        await renderArticles();
      }
    }

    // Show manage feeds popup
    async function showManageFeedsPopup() {
      const feeds = await db.getFeeds();
      const serverUrl = CONFIG.SERVER_URL || 'https://www.hunter-stroud.com/tabink-server';
      
      let popupHTML = `
        <div class="popup active">
          <div class="popup-header">
            <h3 class="popup-title">Feeds</h3>
            <button class="close-btn" onclick="hidePopup()"></button>
          </div>
          <div class="popup-content" style="max-height: 70vh; overflow-y: auto;">
            <div style="background: var(--bg-inset); padding: var(--space-sm); border-radius: var(--radius-sm); margin-bottom: var(--space-md); border: 1px solid var(--border-color);">
              <p class="text-sm muted">Feeds are managed at <a href="${serverUrl}" target="_blank" style="color: var(--accent); text-decoration: underline;">${serverUrl.replace('https://', '')}</a></p>
            </div>
            
            <div class="popup-item${!currentFeedFilter ? ' active' : ''}" style="cursor: pointer;" onclick="filterByFeed(null)">
              <div style="flex: 1;">
                <strong>All Feeds</strong>
                <div class="text-sm muted">Show articles from all sources</div>
              </div>
            </div>
      `;

      if (feeds.length === 0) {
        popupHTML += `
          <div class="empty-state">
            <div class="empty-state-icon">ðŸ“­</div>
            <p>No feeds loaded yet.</p>
            <p class="text-sm muted">Add feeds on the server, then click "Refresh"</p>
          </div>
        `;
      } else {
        feeds.forEach((feed) => {
          const isActive = currentFeedFilter === feed.name;
          popupHTML += `
            <div class="popup-item${isActive ? ' active' : ''}" style="cursor: pointer;" onclick="filterByFeed('${escapeHtml(feed.name).replace(/'/g, "\\'")}')">
              <div style="flex: 1;">
                <strong>${escapeHtml(feed.name)}</strong>
                <div class="text-sm muted" style="overflow: hidden; text-overflow: ellipsis; white-space: nowrap;">${escapeHtml(feed.url)}</div>
              </div>
            </div>
          `;
        });
      }

      popupHTML += `
          </div>
          <div class="popup-footer">
            <span>${currentFeedFilter ? `Filtered: ${currentFeedFilter}` : `${feeds.length} feed${feeds.length !== 1 ? 's' : ''} in database`}</span>
          </div>
        </div>
        <div class="popup-overlay active" onclick="hidePopup()"></div>
      `;

      document.body.insertAdjacentHTML('beforeend', popupHTML);
    }

    // Filter articles by feed
    async function filterByFeed(feedName) {
      currentFeedFilter = feedName;
      hidePopup();
      await renderArticles();
    }

    // Hide popup
    function hidePopup() {
      const popup = document.querySelector('.popup');
      const overlay = document.querySelector('.popup-overlay');
      if (popup) popup.remove();
      if (overlay) overlay.remove();
    }

    // Get time ago
    function getTimeAgo(date) {
      if (!date || isNaN(date.getTime())) {
        return 'Unknown date';
      }
      
      const now = new Date();
      const diffMs = now - date;
      const diffSecs = Math.floor(diffMs / 1000);
      const diffMins = Math.floor(diffSecs / 60);
      const diffHours = Math.floor(diffMins / 60);
      const diffDays = Math.floor(diffHours / 24);
      
      // Debug logging for first call
      if (!window.timeAgoDebugShown) {
        console.log('getTimeAgo debug:', {
          now: now,
          articleDate: date,
          diffMs: diffMs,
          diffSecs: diffSecs,
          diffMins: diffMins,
          diffHours: diffHours
        });
        window.timeAgoDebugShown = true;
      }
      
      if (diffSecs < 0) return 'Just now';
      if (diffSecs < 60) return `${diffSecs}s ago`;
      if (diffMins < 60) return `${diffMins}m ago`;
      if (diffHours < 24) return `${diffHours}h ago`;
      if (diffDays < 30) return `${diffDays}d ago`;
      return date.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
    }
  </script>
</body>
</html>
